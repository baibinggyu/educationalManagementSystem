红黑树插入后的调整需要处理 5种主要情况，这些情况是根据新插入节点的位置和周围节点的颜色决定的。以下是详细的分类和解释：

红黑树插入后的调整情况
基本情况分类
调整的核心是处理 "红色父子冲突"（即红色节点的父节点也是红色，违反红黑树性质4）。所有情况都基于以下三个节点的关系判断：

新插入节点（z，总是红色）
父节点（z->parent，可能是红色）
叔节点（uncle，父节点的兄弟节点，颜色影响处理方式）
祖父节点（grandparent，父节点的父节点，必定是黑色）
5种调整情况
情况1：插入的是根节点
条件：新节点是树的根（无父节点）。
处理：
直接将其颜色设为黑色（满足性质2）。c
示例：
C
if (z->parent == NULL) {
    z->color = BLACK;
    return;
}
情况2：父节点是黑色
条件：父节点是黑色。
处理：
无需调整，直接插入红色节点不影响性质。
示例：
C
if (z->parent->color == BLACK) {
    return; // 无冲突
}
情况3：父节点和叔节点都是红色
条件：
父节点和叔节点均为红色。
处理：
将父节点和叔节点变为黑色。
将祖父节点变为红色。
将祖父节点作为新的当前节点（z = grandparent），继续向上调整。
目的：
将红色冲突向上传递，可能递归到根。
示例：
C
uncle->color = BLACK;
z->parent->color = BLACK;
grandparent->color = RED;
z = grandparent; // 继续检查祖父节点
情况4：父节点是红色，叔节点是黑色，且当前节点是父节点的右孩子（LR型）
条件：
父节点是红色，叔节点是黑色。
当前节点是父节点的右孩子（形成"左-右"结构）。
处理：
以父节点为支点 左旋，转换为情况5。
将父节点作为新的当前节点（z = z->parent）。
目的：
将树结构调整为线性（方便后续右旋）。
示例：
C
if (z == z->parent->right) {
    z = z->parent;
    leftRotate(root, z); // 左旋后转为情况5
}
情况5：父节点是红色，叔节点是黑色，且当前节点是父节点的左孩子（LL型）
条件：
父节点是红色，叔节点是黑色。
当前节点是父节点的左孩子（形成"左-左"结构）。
处理：
将父节点变为黑色。
将祖父节点变为红色。
以祖父节点为支点 右旋。
目的：
通过旋转和重新着色消除红色冲突。
示例：
C
z->parent->color = BLACK;
grandparent->color = RED;
rightRotate(root, grandparent);
调整流程总结
从下到上：先插入节点，再向上递归调整。
颜色翻转（情况3）或 旋转（情况4/5）解决冲突。
最终确保根节点为黑色（可能在递归中修改根的颜色）。
完整调整函数代码示例

关键点
旋转操作：通过左旋/右旋改变树结构。
颜色翻转：解决局部红色冲突。
递归向上：可能从叶子调整到根。
时间复杂度：每次插入最多需要 O(log n) 次调整（树的高度）。